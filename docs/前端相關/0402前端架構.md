# 虛擬宇航員互動系統 – 前端架構概況 (基於 Zustand 重構後)

## 引言

本文檔旨在描述 `space_live_project` 前端應用在經歷 **Zustand 狀態管理重構**後的當前架構。此架構旨在提升應用的可維護性、可擴展性，並解決先前版本中存在的效能瓶頸和狀態管理複雜性問題。核心技術棧包括 React、TypeScript、React Three Fiber (R3F)、Drei 以及 **Zustand**。

## 專案目錄結構與模組設計

專案採用了基於功能的模組化目錄結構，主要源代碼位於 `src/` 目錄下：

-   **main.tsx**：應用程式的進入點，負責初始化 React 應用並掛載根組件 `<App />`。
-   **App.tsx**：應用的根組件。負責初始化核心服務 Hooks、設定全局上下文（如果需要）、組合主要的 UI 佈局（如 3D 場景和控制面板）。
-   **components/**：存放可重用的 React UI 組件。
    -   `AppUI.tsx`: 整合主要的 2D UI 界面，如控制面板、聊天視窗等。
    -   `SceneContainer.tsx`: 負責設定 React Three Fiber 的 `<Canvas>`，並容納 3D 場景相關組件。
    -   `Model.tsx`: 負責載入和渲染 3D 模型，並處理基礎的 `useFrame` 動畫循環（如 Morph Target 插值）。
    -   `ControlPanel.tsx`: 包含各種控制按鈕和滑桿，用於與模型和應用互動。
    -   `ChatInterface.tsx`: 顯示聊天訊息和輸入框。
    -   `AudioControls.tsx`: 提供錄音、播放等音頻控制 UI。
    -   其他輔助 UI 組件...
-   **hooks/**：存放自定義的 React Hooks，用於封裝可重用的邏輯，特別是與服務或 Zustand 狀態相關的邏輯。
    -   `useWebSocketService.ts`, `useChatService.ts`, `useAudioService.ts`, `useModelService.ts`: 這些 Hooks 通常負責在組件掛載時初始化對應的 Service 實例，並可能返回 Service 實例或與之互動的方法。
-   **services/**：包含核心的業務邏輯和副作用處理。**重構後，Service 主要負責與後端交互（API, WebSocket）、執行複雜計算或流程，並通過調用 Zustand Actions 來更新全局狀態，自身不再儲存大量需要跨組件共享的狀態。**
    -   `WebSocketService.ts`: 管理 WebSocket 連接、消息收發和重連邏輯。收到後端消息後，會解析並觸發相應的 Zustand Action。
    -   `ChatService.ts`: 處理聊天相關邏輯，調用後端對話 API，並更新 Zustand 中的聊天記錄狀態。
    -   `AudioService.ts`: 處理麥克風錄音、音頻播放、調用 STT/TTS API，並更新 Zustand 中的音頻相關狀態（如錄音狀態、播放狀態）。
    -   `ModelService.ts`: 負責模型的加載切換邏輯、調用後端獲取表情預設、觸發 Zustand 更新模型的 Morph Target Dictionary 和初始值。**不再直接持有 `morphTargets` 狀態。**
    -   `api.ts`: 封裝所有對後端 RESTful API 的請求（使用 `fetch` 或 axios）。提供了如 `speechToText` (已修復為發送 Blob), `getPresetExpression` 等函數。
-   **store/**：**Zustand 全局狀態管理的核心目錄。**
    -   `index.ts`: 創建並導出 Zustand store 實例 (`useStore`)，整合所有 Slices。
    -   `slices/`: 包含各個狀態分片（Slice），每個 Slice 定義一部分相關的 State 和 Actions。
        -   `AppSlice.ts`: 應用級別的狀態，如加載狀態、全局錯誤等。
        -   `WebSocketSlice.ts`: WebSocket 連接狀態。
        -   `ChatSlice.ts`: 聊天記錄、當前輸入、AI 回應狀態等。
        -   `ModelSlice.ts`: 當前模型 URL、加載狀態、**`morphTargets`** (表情/嘴型數值)、**`morphTargetDictionary`** (可用表情名稱)、當前動畫等。
        -   `AudioSlice.ts`: 錄音狀態 (`isRecording`)、播放狀態 (`isPlaying`)、識別出的文本等。
-   **types/**：存放 TypeScript 的類型定義和接口。
-   **utils/**：存放通用的輔助函數和工具類，如 `LogManager.ts`。

整體遵循模組化和關注點分離原則，UI 組件負責渲染，Hooks 封裝邏輯，Services 處理副作用和業務流程，Zustand Store 集中管理全局狀態。

## 狀態管理策略 (基於 Zustand)

**Zustand** 是當前架構的核心，取代了之前依賴服務內部狀態和手動事件訂閱的模式。

-   **單一全局 Store (`useStore`)**：應用中存在一個由 Zustand 創建的全局 Store，通過 `src/store/index.ts` 導出 `useStore` Hook。
-   **狀態分片 (Slices)**：全局狀態被劃分到不同的 Slices (`src/store/slices/`) 中進行管理，每個 Slice 包含相關的狀態 (State) 和用於修改這些狀態的函數 (Actions)。例如，`ModelSlice` 管理所有與 3D 模型表現相關的狀態。
-   **組件讀取狀態**：React 組件通過 `useStore` Hook 訂閱所需的狀態。利用 Selector (`useStore(state => state.model.morphTargets)`) 可以精確地只訂閱需要的狀態片段，避免不必要的重渲染。
-   **組件/服務更新狀態**：
    -   當用戶在 UI 上進行操作（如點擊按鈕、拖動滑桿）時，事件處理函數會調用 `useStore.setState()` 或預定義的 Action (`useStore.getState().startRecording()`) 來更新 Store 中的狀態。
    -   當 Service 完成一個異步操作（如 API 請求成功、收到 WebSocket 消息）時，它會調用相應的 Action 來更新 Store (`useStore.getState().addChatMessage(...)`)。
-   **數據流**：遵循單向數據流原則。
    1.  **用戶交互/後端事件** 觸發 **Action**。
    2.  **Action** 修改 **Zustand Store** 中的狀態。
    3.  **Zustand** 通知訂閱了該狀態變化的 **組件** 進行重渲染。
    4.  **組件** 讀取更新後的狀態並展示。
-   **本地狀態**：對於僅限於單個組件內部使用的臨時狀態（如表單輸入、開關狀態），仍然可以使用 React 的 `useState` Hook。
-   **優勢**：
    -   **集中化**：所有全局狀態集中管理，易於追蹤和調試（可配合 Redux DevTools）。
    -   **簡潔 API**：Zustand 的 API 非常簡潔，學習成本低。
    -   **性能優化**：基於訂閱和 Selector 的機制，可以有效減少不必要的組件重渲染。
    -   **解耦**：組件與服務之間通過 Zustand 解耦，組件只需關心狀態本身，而服務只需關心觸發狀態更新。
    -   **解決歷史問題**：有效解決了之前手動管理訂閱可能導致的內存洩漏、狀態更新混亂以及過度重繪等問題。

## API 與後端的整合方式

前端與後端的通信依然通過 **REST API** 和 **WebSocket** 進行，但整合方式已圍繞 Zustand 進行了優化：

-   **WebSocket (`WebSocketService`)**：
    -   負責建立和維護與後端的實時連接。
    -   **接收消息**：當收到來自後端的消息（如 `lipsync_update`, `chat_message`）時，`WebSocketService` 會解析消息內容，並調用 **Zustand Store 中對應的 Action** 來更新狀態（例如 `useStore.getState().updateMorphTargets(data)` 或 `useStore.getState().addChatMessage(message)`）。
    -   **發送消息**：當需要向後端發送消息時（如用戶發送聊天文本），相關組件或 Service 會調用 `WebSocketService` 提供的方法，服務再通過 WebSocket 連接發送。
    -   **狀態同步**：WebSocket 的連接狀態（連接中、已連接、已斷開）也由 `WebSocketSlice` 在 Zustand Store 中管理。
-   **REST API (`services/api.ts`)**：
    -   封裝了對後端 HTTP 接口的請求，例如獲取預設表情 (`getPresetExpression`)、上傳錄音進行語音識別 (`speechToText`) 等。
    -   **請求與響應**：當 Service（如 `AudioService`, `ModelService`）需要調用 API 時，會調用 `api.ts` 中封裝好的函數。
    -   **狀態更新**：API 請求成功返回數據後，調用方 Service 會負責解析數據，並觸發 **Zustand Action** 來更新相關狀態。例如，`AudioService` 在 `speechToText` 成功後，會調用 `useStore.getState().setRecognizedText(text)`。
    -   **錯誤處理**：API 請求的錯誤處理也包含在內，可能會觸發更新 Store 中的錯誤狀態。
-   **整合流程示例 (語音識別)**：
    1.  用戶點擊錄音按鈕 (`AudioControls.tsx`)。
    2.  觸發 `useStore.getState().startRecording()` Action，更新 `AudioSlice` 中 `isRecording` 為 `true`。
    3.  `AudioService` 監聽到狀態變化或被直接調用，開始錄音。
    4.  用戶停止錄音。
    5.  觸發 `useStore.getState().stopRecording()` Action。
    6.  `AudioService` 停止錄音，獲取音頻 Blob。
    7.  `AudioService` 調用 `api.speechToText(blob)`。
    8.  API 請求成功，後端返回識別文本。
    9.  `AudioService` 調用 `useStore.getState().setRecognizedText(text)` 更新 `ChatSlice` 或 `AudioSlice` 中的狀態。
    10. `ChatInterface.tsx` 或相關組件監聽到文本變化，顯示識別結果。
-   **優勢**：這種整合方式使得後端數據能夠順暢地流入 Zustand Store，成為前端狀態的一部分，UI 則響應式地反映這些狀態變化，流程清晰且易於管理。

## 架構圖 (Mermaid)

```mermaid
graph TD
    subgraph Browser / User Interface
        direction TB
        User[User Interaction] --> UI["React Components (App, ControlPanel, Model, ChatInterface, etc.)"]
    end

    subgraph Frontend Logic & State
        direction TB
        UI -- Reads state / Subscribes --> Store["Zustand Store (Slices: Model, Chat, Audio, WS, App)"]
        UI -- Dispatches --> Actions[Zustand Actions]
        Actions -- Mutates --> Store
        Services["Services (WebSocket, Chat, Audio, Model, API)"] -- Calls --> Actions
        Services -- Handles --> SideEffects["Side Effects (API Calls, WebSocket I/O)"]
    end

    subgraph Backend Systems
        direction TB
        SideEffects -- Interacts with --> Backend[Backend (WebSocket Server, REST API, AI Services)]
    end

    %% Data Flow Arrows
    User -- Triggers UI Events --> UI
    UI -- Triggers Actions --> Actions
    Backend -- Sends Data --> SideEffects
    SideEffects -- Triggers Actions after processing data --> Actions

    %% Class Styles
    classDef ui fill:#cef,stroke:#5a9,stroke-width:2px
    classDef state fill:#f9f,stroke:#c6c,stroke-width:2px
    classDef logic fill:#fcc,stroke:#f66,stroke-width:2px
    classDef backend fill:#efe,stroke:#393,stroke-width:2px

    class User ui
    class UI ui
    class Store state
    class Actions state
    class Services logic
    class SideEffects logic
    class Backend backend
```

**圖例說明:**

1.  **用戶交互 (User Interaction)** 觸發 **React 組件 (UI)** 中的事件。
2.  **UI 組件** 調用 **Zustand Actions** 來表達意圖或更新請求。
3.  **Actions** 修改 **Zustand Store** 中的狀態。
4.  **Zustand Store** 狀態變更後，會通知訂閱了相關狀態的 **UI 組件** 進行重渲染。**UI 組件** 從 Store 中讀取最新狀態。
5.  某些 **Actions** 或 **UI 事件** 可能會觸發 **Services** 中的邏輯。
6.  **Services** 負責處理 **副作用 (Side Effects)**，例如與 **後端 (Backend)** 進行 API 調用或 WebSocket 通信。
7.  **Services** 在處理完副作用或收到後端數據後，會調用 **Zustand Actions** 來更新 Store。

這個架構通過 Zustand 實現了清晰的狀態管理和單向數據流，顯著提高了應用的可維護性和開發效率。
