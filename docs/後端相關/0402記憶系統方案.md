# 記憶系統與對話管理方案 (v3 - LangGraph 實作)

**更新日期:** 2023-10-27 (根據實際日期調整)

## 1. 架構概述

為了提高程式碼的可維護性、可讀性和擴展性，AI 核心邏輯被拆分為兩個主要模組：

1.  **`MemorySystem` (`prototype/backend/services/ai/memory_system.py`)**: 專注於記憶的儲存、檢索、管理和整合。封裝了與向量數據庫 (Chroma) 的互動以及記憶處理邏輯。
2.  **`DialogueGraph` (`prototype/backend/services/ai/dialogue_graph.py`)**: 使用 **LangGraph** 構建的對話流程圖。它定義了對話生成的各個步驟（節點）以及它們之間的流轉邏輯（邊），並管理對話過程中的狀態。

`DialogueGraph` 在執行過程中會調用 `MemorySystem` 來獲取記憶上下文，並在流程結束時調用 `MemorySystem` 來儲存對話。

為了向後兼容，`prototype/backend/services/ai/__init__.py` 提供了一個 `AIService` 適配器類，對外暴露與舊版相同的接口，但內部實例化並調用 `DialogueGraph` 和 `MemorySystem`。

## 2. `MemorySystem` 詳細設計

### 2.1 主要職責

*   初始化和管理向量數據庫 (Chroma)，包含獨立的「對話記憶庫」和「角色信息記憶庫」。
*   在啟動時加載或初始化核心角色身份信息到「角色信息記憶庫」。
*   提供異步接口 (`retrieve_context`) 供 `DialogueGraph` 的節點調用，以檢索相關的對話記憶和角色信息。
    *   內部使用增強查詢進行檢索。
    *   使用 MMR 提高對話記憶檢索的多樣性。
    *   並行檢索對話記憶和角色信息。
*   提供接口 (`store_conversation_turn`) 供 `DialogueGraph` 的節點調用，以儲存完成的對話輪次。
    *   自動檢查是否需要更新「角色信息記憶庫」。
*   包含記憶格式化、去重、相似度計算等輔助邏輯。
*   實現定期記憶整合 (`consolidate_memories`) 的觸發邏輯（具體整合操作可在內部完成或由外部觸發）。

### 2.2 數據結構

*   `conversation_memory`: Chroma 實例，儲存 `input: ... output: ...` 格式的對話文本。
*   `persona_memory`: Chroma 實例，儲存關於角色自身的事實和特性。
*   元數據 (Metadata): 儲存時附加時間戳、類型等信息。

## 3. `DialogueGraph` 詳細設計

### 3.1 主要職責

*   定義對話流程圖 (`StateGraph`)，包含多個節點 (Nodes) 和邊 (Edges)。
*   定義對話狀態數據結構 (`DialogueState`)，用於在節點間傳遞信息。
*   實現圖中的各個節點函數，每個節點負責對話流程中的一個具體步驟，例如：
    *   `_retrieve_memory_node`: 調用 `MemorySystem` 檢索記憶。
    *   `_prepare_context_node`: 格式化歷史、選擇風格、格式化狀態。
    *   `_build_prompt_node`: 構建傳給 LLM 的輸入。
    *   `_call_llm_node`: 調用 LLM 生成原始回應。
    *   `_post_process_node`: 後處理回應 (如移除固定開場白)。
    *   `_store_memory_node`: 調用 `MemorySystem` 儲存對話，並更新狀態中的 `messages` 列表。
*   編譯圖 (`self.app = self.graph.compile()`) 得到可執行的應用。
*   提供 `generate_response` 方法作為外部接口，負責準備初始狀態 (`initial_state`)，調用 `self.app.ainvoke(initial_state)` 執行圖，並從最終狀態中提取結果。
*   提供管理角色狀態的方法 (`update_character_state`, `reset`)。

### 3.2 狀態管理 (`DialogueState`)

`DialogueState` (TypedDict) 包含了流程中需要的所有信息，例如：
`user_input`, `messages` (完整歷史), `relevant_memories`, `persona_info`, `conversation_history` (提示用), `dialogue_style`, `character_state_prompt`, `prompt_inputs`, `character_state` (字典), `current_task`, `tasks_history`, `ai_response_raw`, `ai_response`。

狀態在圖中流動，每個節點可以讀取狀態並返回一個字典來更新狀態的特定部分。

### 3.3 提示工程

*   提示模板 (`DIALOGUE_PROMPT_TEMPLATE`) 與 v2 類似，但在 `_build_prompt_node` 中動態填充。
*   互動原則依然重要，指導 LLM 在圖的 `_call_llm_node` 步驟中如何表現。

## 4. 互動流程 (`AIService.generate_response`)

1.  **用戶輸入**: `AIService` 接收 `user_text`。
2.  **準備初始狀態**: `AIService` 準備 `initial_state`，包含 `user_text`, 當前的 `self.messages`, `self.character_state` 等。
3.  **調用圖**: `AIService` 調用 `dialogue_graph.generate_response`。
4.  **圖執行**: `DialogueGraph` 調用 `self.app.ainvoke(initial_state)`。
    *   LangGraph 引擎根據圖的定義，依次執行節點：
        *   `retrieve_memory` (調用 `MemorySystem`)
        *   `prepare_context`
        *   `build_prompt`
        *   `call_llm` (調用 LLM)
        *   `post_process`
        *   `store_memory` (調用 `MemorySystem`，更新狀態中的 `messages`)
    *   狀態 (`DialogueState`) 在節點間傳遞並被更新。
5.  **獲取結果**: `app.ainvoke` 返回最終狀態 `final_state`。
6.  **提取結果**: `DialogueGraph.generate_response` 從 `final_state` 提取 `ai_response` 和 `updated_messages`。
7.  **狀態同步**: `AIService` 更新自己的 `self.messages`。 (`character_state` 由 `AIService` 獨立管理，但在調用圖時傳入)。
8.  **返回結果**: `AIService` 返回 `ai_response` 給調用者。

## 5. 未來擴展方向 (基於 LangGraph)

*   **工具調用 (Tool Calling)**: 在圖中加入 `ToolNode` 或自定義工具調用節點，並添加條件邊來處理工具執行流程。
*   **自我修正/反思循環**: 添加條件邊，讓 LLM 輸出不佳時可以觸發反思、重新規劃或重新調用 LLM 的循環。
*   **更複雜的分支邏輯**: 根據檢索到的記憶內容、用戶意圖或角色狀態，使用條件邊將流程導向不同的處理節點。
*   **人機協作點**: 利用 LangGraph 的中斷能力，在特定節點暫停等待外部輸入（例如，讓用戶確認某個操作）。
*   **記憶整合節點**: 將 `consolidate_memories` 邏輯實現為圖中的一個可選節點或獨立的圖。
*   **多 Agent 協作**: 如果未來需要多個 AI 角色或助手協同工作，LangGraph 提供了構建這種複雜交互的框架。