# 記憶系統與對話管理方案 (v3.1 - LangGraph 實作詳解)

**更新日期:** 2023-10-27 (根據實際日期調整)

## 1. 架構概述：流程即圖

本方案採用 **LangGraph** 作為核心，將 AI 的記憶與對話生成過程建模為一個**有狀態的圖 (State Graph)**。取代了傳統的單一服務類或線性鏈條，這種方法將複雜的交互邏輯拆分為獨立的步驟（節點）和清晰的流轉規則（邊），顯著提高了系統的模塊化程度、可讀性、可測試性和未來擴展性。

**核心組件:**

1.  **`MemorySystem` (`prototype/backend/services/ai/memory_system.py`)**: **長期記憶中心**。專職管理與向量數據庫 (Chroma) 的交互，負責記憶的儲存、檢索、格式化和（未來可能的）整合。
2.  **`DialogueGraph` (`prototype/backend/services/ai/dialogue_graph.py`)**: **對話流程引擎**。基於 LangGraph 實現，定義了對話生成的狀態 (`DialogueState`)、各個處理步驟（節點，如記憶檢索、LLM調用、後處理等）以及這些步驟間的執行順序（邊）。
3.  **`AIService` (適配器) (`prototype/backend/services/ai/__init__.py`)**: **外部接口與兼容層**。維持與舊版系統相同的接口，方便現有模組（如 API 端點）調用。內部實例化並協調 `MemorySystem` 和 `DialogueGraph`，管理應用程式級別的狀態（如完整對話歷史、角色狀態）。

## 2. `MemorySystem` 詳細設計

`MemorySystem` 是 AI 的記憶中樞，其設計保持相對穩定。

### 2.1 主要職責

*   **數據庫管理**: 初始化並維護兩個獨立的 Chroma 向量集合：
    *   `conversation_memory`: 存儲實際的用戶-AI 對話輪次。
    *   `persona_memory`: 存儲關於 AI 角色（星際小可愛）的核心身份信息、特性和學習到的新事實。
*   **核心記憶初始化**: 在系統首次啟動或 `persona_memory` 為空時，自動添加預設的核心角色信息（名字、背景、性格等）。
*   **上下文檢索 (`retrieve_context`)**: 提供異步接口，供 `DialogueGraph` 調用。接收當前用戶輸入和最近的對話歷史，執行以下操作：
    1.  構建**增強查詢 (Enhanced Query)**，結合用戶意圖和歷史上下文。
    2.  **並行**地向 `conversation_memory` 和 `persona_memory` 發起檢索請求。
    3.  對 `conversation_memory` 使用 **MMR (Maximal Marginal Relevance)** 算法，確保檢索結果既相關又具備多樣性。
    4.  對 `persona_memory` 進行標準的相似性搜索，獲取最相關的角色信息。
    5.  **格式化與去重**: 對檢索到的對話記憶進行處理，去除高度相似的內容，返回清晰、簡潔的記憶片段。
    6.  返回格式化後的對話記憶和角色信息給調用者。
*   **對話儲存 (`store_conversation_turn`)**: 提供接口，供 `DialogueGraph` 在一輪對話結束後調用。將用戶輸入和最終 AI 回應存入 `conversation_memory`，並附加時間戳等元數據。
*   **角色記憶更新 (`_check_and_update_persona_memory`)**: 在儲存對話時，自動分析對話內容（基於關鍵詞或未來可引入 LLM 判斷），如果發現包含關於 AI 自身的新信息或重要陳述，則將其處理後存入 `persona_memory`。
*   **記憶整合 (`consolidate_memories`)**: 提供一個定期觸發的接口（目前主要記錄調用），為未來實現更高級的記憶整合（如生成摘要、遺忘不重要信息）預留空間。

### 2.2 數據結構

*   向量數據庫條目包含文本內容和元數據（如 `type`, `timestamp`）。

## 3. `DialogueGraph` 詳細設計 (LangGraph 核心)

`DialogueGraph` 是對話邏輯的核心，將流程步驟轉化為圖的節點和邊。

### 3.1 核心概念

*   **狀態 (`DialogueState`)**: 使用 `TypedDict` 定義了一個包含所有流程所需信息的結構。它像一個流動的數據載體，在圖的節點之間傳遞。包含：用戶輸入、完整消息歷史 (`messages`)、檢索到的記憶、格式化的歷史 (提示用)、選擇的風格、角色狀態字典、LLM 的原始輸出、最終輸出等。
*   **節點 (Nodes)**: 代表圖中的一個處理單元，通常是一個 Python 函數。每個節點接收當前的 `DialogueState`，執行特定任務，並返回一個字典來**部分更新** `DialogueState`。
*   **邊 (Edges)**: 連接節點，定義了狀態的流動方向。目前是線性流程，但可擴展為條件分支或循環。
*   **圖 (`StateGraph`)**: 將節點和邊組織起來，定義入口點和出口點 (`END`)。
*   **編譯應用 (`self.app`)**: `compile()` 方法將圖轉換為可執行的異步函數 (`ainvoke`)。

### 3.2 主要節點實現

1.  `_retrieve_memory_node`: 調用 `MemorySystem.retrieve_context`，將結果更新到狀態的 `relevant_memories` 和 `persona_info`。
2.  `_prepare_context_node`: 根據狀態中的 `messages` 格式化 `conversation_history`；根據 `character_state` 選擇 `dialogue_style` 和格式化 `character_state_prompt`；更新對應的狀態鍵。
3.  `_build_prompt_node`: 從狀態中讀取所有需要的信息（用戶輸入、歷史、記憶、狀態描述、風格等），組裝成一個字典，更新到狀態的 `prompt_inputs`。
4.  `_call_llm_node`: 使用狀態中的 `prompt_inputs` 調用 `self.chain` (Prompt | LLM | Parser)，將原始 LLM 輸出更新到 `ai_response_raw`。
5.  `_post_process_node`: 讀取 `ai_response_raw`，執行清理（去開場白、去 Emoji），將結果更新到 `ai_response`。
6.  `_store_memory_node`: 讀取 `user_input` 和 `ai_response`，調用 `MemorySystem.store_conversation_turn`；將 `AIMessage(content=ai_response)` 添加到狀態的 `messages` 列表末尾。

### 3.3 外部接口 (`generate_response`)

*   這是 `DialogueGraph` 類暴露給 `AIService` 的方法。
*   負責接收外部傳入的當前對話狀態（用戶輸入、歷史消息、角色狀態）。
*   創建 LangGraph 執行所需的 `initial_state` 字典。
*   調用 `await self.app.ainvoke(initial_state)` 執行圖。
*   從返回的 `final_state` 中提取 `ai_response` 和更新後的 `messages` 列表。
*   返回這兩個結果給 `AIService`。

## 4. `AIService` (適配器) 詳細設計

`AIService` 作為門面，簡化了外部調用並保持兼容性。

### 4.1 主要職責

*   **初始化**: 創建 `MemorySystem` 和 `DialogueGraph` 的實例。
*   **狀態持有**: 維護應用程式生命週期內的對話歷史 (`self.messages`) 和角色狀態 (`self.character_state`)。
*   **接口兼容**: 提供與舊版一致的 `generate_response`, `update_character_state`, `set_current_task`, `complete_current_task`, `advance_day` 等方法。
*   **流程委派**: 在其方法內部，調用 `DialogueGraph` 的相應方法來執行核心邏輯。
*   **狀態傳遞與同步**: 在調用 `DialogueGraph.generate_response` 時傳入當前狀態，並在接收到返回結果後更新自身的 `self.messages`。角色狀態的更新則通過調用 `DialogueGraph.update_character_state` 並同步結果來完成。

## 5. 完整互動流程詳解 (`AIService.generate_response`)

1.  **外部請求**: API 端點收到 `user_text`。
2.  **AIService 接收**: `ai_service.generate_response(user_text)` 被調用。
3.  **準備圖輸入**: `AIService` 整理好 `user_text`、當前的 `self.messages` 和 `self.character_state`。
4.  **調用 DialogueGraph**: `AIService` 調用 `dialogue_graph.generate_response(...)`。
5.  **構建初始狀態**: `DialogueGraph` 內部創建 `initial_state` 字典。
6.  **執行 LangGraph 圖**: `await self.app.ainvoke(initial_state)` 開始執行。
    *   狀態按 `retrieve_memory` -> `prepare_context` -> `build_prompt` -> `call_llm` -> `post_process` -> `store_memory` 的順序在節點間流動。
    *   每個節點讀取所需狀態，執行任務，返回更新後的部分狀態。
    *   `MemorySystem` 在 `retrieve_memory` 和 `store_memory` 節點被調用。
7.  **圖執行完畢**: `app.ainvoke` 返回包含所有更新的 `final_state`。
8.  **提取圖結果**: `DialogueGraph.generate_response` 從 `final_state` 提取 `ai_response` 和 `updated_messages`。
9.  **AIService 更新**: `AIService.generate_response` 接收到結果，用 `updated_messages` 更新 `self.messages`。
10. **返回最終回應**: `AIService` 將 `ai_response` 返回給 API 端點。

## 6. 基於 LangGraph 的未來擴展方向

LangGraph 的架構為未來的功能增強提供了極大便利：

*   **工具使用**: 添加專門的工具調用節點 (`ToolNode` 或自定義)，並使用條件邊判斷何時需要調用工具、處理工具輸出。
*   **反思與修正**: 設計循環路徑，例如：如果 `_post_process_node` 判斷回應質量差，可以增加一個反思節點，然後重新進入 `_build_prompt_node` 或 `_call_llm_node` 進行修正。
*   **動態流程**: 根據用戶意圖或對話狀態（例如，用戶明顯在閒聊 vs. 執行任務），通過條件邊引導到不同的處理子圖或節點序列。
*   **更複雜的狀態管理**: 在 `DialogueState` 中添加更多維度的狀態（如用戶情緒、對話目標達成度），並讓節點根據這些狀態做出更細緻的決策。
*   **人機協作**: 在需要用戶確認或提供額外信息時，可以在圖中設計中斷點。