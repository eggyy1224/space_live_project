# 記憶系統與對話管理方案 (v2 - 模組化架構)

**更新日期:** 2023-10-27 (根據實際日期調整)

## 1. 架構概述

為了提高程式碼的可維護性、可讀性和擴展性，原始的 `AIService` 已被拆分為兩個核心模組：

1.  **`MemorySystem` (`prototype/backend/services/ai/memory_system.py`)**: 專注於記憶的儲存、檢索、管理和整合。封裝了與向量數據庫 (Chroma) 的互動以及記憶處理邏輯。
2.  **`DialogueManager` (`prototype/backend/services/ai/dialogue_manager.py`)**: 負責驅動對話流程，管理短期對話歷史、角色狀態、選擇對話風格、構建提示、與 LLM 互動以及後處理回應。

這兩個模組互相協作，`DialogueManager` 調用 `MemorySystem` 來獲取上下文記憶，並在生成回應後通知 `MemorySystem` 儲存對話。

為了向後兼容，`prototype/backend/services/ai/__init__.py` 提供了一個 `AIService` 適配器類，對外暴露與舊版相同的接口，但內部調用新的 `DialogueManager` 和 `MemorySystem`。

## 2. `MemorySystem` 詳細設計

### 2.1 主要職責

*   初始化和管理向量數據庫 (Chroma)，包含獨立的「對話記憶庫」和「角色信息記憶庫」。
*   在啟動時加載或初始化核心角色身份信息到「角色信息記憶庫」。
*   提供異步接口 (`retrieve_context`) 供 `DialogueManager` 調用，以檢索相關的對話記憶和角色信息。
    *   內部使用增強查詢（結合用戶輸入和對話歷史）進行檢索。
    *   使用 MMR (Maximal Marginal Relevance) 提高對話記憶檢索的多樣性。
    *   並行檢索對話記憶和角色信息。
*   提供接口 (`store_conversation_turn`) 供 `DialogueManager` 調用，以儲存完成的對話輪次。
    *   自動檢查是否需要更新「角色信息記憶庫」（例如，當對話涉及角色身份時）。
*   包含記憶格式化、去重、相似度計算等輔助邏輯。
*   (可選/未來擴展) 實現定期記憶整合 (`consolidate_memories`) 的邏輯，例如生成摘要或清理過時記憶。

### 2.2 數據結構

*   `conversation_memory`: Chroma 實例，儲存 `input: ... output: ...` 格式的對話文本。
*   `persona_memory`: Chroma 實例，儲存關於角色自身的事實和特性。
*   元數據 (Metadata): 儲存時附加時間戳、類型（`conversation`, `core_identity`, `learned_identity`）等信息。

## 3. `DialogueManager` 詳細設計

### 3.1 主要職責

*   接收 `MemorySystem` 和 `LLM` 實例作為依賴。
*   管理當前會話的短期記憶列表 (`self.messages`)。
*   管理角色狀態 (`self.character_state`)，包括健康、心情、能量等，並提供更新接口 (`update_character_state`)，支持增量更新。
*   管理當前任務 (`self.current_task`) 和任務歷史 (`self.tasks_history`)。
*   根據角色狀態動態選擇對話風格 (`_select_dialogue_style`)。
*   格式化角色狀態為自然語言描述 (`_format_character_state`)。
*   實現 `generate_response` 核心流程：
    1.  將用戶輸入添加到 `self.messages`。
    2.  調用 `memory_system.retrieve_context` 獲取記憶。
    3.  準備提示所需的各種信息（歷史、記憶、狀態、風格等）。
    4.  構建輸入字典，調用 LLM 鏈 (`self.chain`) 生成原始回應。
    5.  對原始回應進行後處理 (`_post_process_response`)，例如移除固定的開場白。
    6.  將最終回應添加到 `self.messages`。
    7.  調用 `memory_system.store_conversation_turn` 儲存對話。
    8.  (可選) 觸發 `memory_system.consolidate_memories`。
*   提供錯誤處理機制，返回友好的錯誤回應。

### 3.2 提示工程

*   使用結構化的提示模板 (`DIALOGUE_PROMPT_TEMPLATE`)。
*   明確包含角色核心特質、當前狀態、任務、風格提示、記憶、歷史和互動原則。
*   指導 LLM 如何自然地使用記憶、處理矛盾和執行任務。
*   強調避免刻板的自我介紹。

## 4. 互動流程 (`generate_response`)

1.  **用戶輸入**: `DialogueManager` 接收 `user_text`。
2.  **短期歷史更新**: 將 `user_text` 加入 `DialogueManager.messages`。
3.  **記憶檢索**: `DialogueManager` 構建查詢，調用 `MemorySystem.retrieve_context`，獲取 `relevant_memories` 和 `persona_info`。
4.  **上下文準備**: `DialogueManager` 格式化歷史、選擇風格、格式化狀態。
5.  **提示構建**: `DialogueManager` 將所有信息填入 `prompt_template`。
6.  **LLM 調用**: `DialogueManager` 通過 `self.chain` 將構建好的輸入傳給 LLM。
7.  **回應生成**: LLM 返回 `ai_response_raw`。
8.  **後處理**: `DialogueManager._post_process_response` 清理回應，得到 `ai_response`。
9.  **短期歷史更新**: 將 `ai_response` 加入 `DialogueManager.messages`。
10. **記憶儲存**: `DialogueManager` 調用 `MemorySystem.store_conversation_turn` 儲存 `user_text` 和 `ai_response`。
11. **記憶整合 (可選)**: `DialogueManager` 觸發 `MemorySystem.consolidate_memories`。
12. **返回結果**: `DialogueManager` 返回 `ai_response` 給調用者。

## 5. 未來擴展方向

*   實現更複雜的記憶整合邏輯 (`consolidate_memories`)。
*   引入工具使用能力 (Tool Calling)，讓 AI 可以調用外部 API 或函數。
*   在 `MemorySystem` 中實現更精確的相似度計算或信息提取方法。
*   在 `DialogueManager` 中增加更細緻的情感模擬或決策邏輯。
*   考慮將提示模板字串移至單獨的 `prompts.py` 文件。
*   研究使用 LangGraph 優化複雜對話流程的可能性。