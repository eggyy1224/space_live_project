# 前端 UI/UX 重構計畫 (20250407 - 精煉版 v2)

## 目標

-   解決介面擁擠問題，降低視覺負擔。
-   優化控制項，突出核心聊天功能。
-   實現頭部/身體分割視圖，分別強調表情與動作。
-   引入浮動、可調整大小的聊天視窗，提升互動彈性。
-   採用 Tailwind CSS 實現現代化、簡潔且一致的 UI 風格。

## TODO 列表

### Phase 1: 環境設定與基礎佈局

1.  **[x] 設定 Tailwind CSS 環境 (使用 v4 + Vite 插件)**
    *   [x] **安裝相關依賴：** `tailwindcss`, `postcss`, `autoprefixer`, `@tailwindcss/vite`。
    *   ~~[ ] **產生設定檔：** 生成 `tailwind.config.js` 和 `postcss.config.js`。~~ (v4 不需要 `init`)
    *   [ ] **配置內容掃描路徑 (`tailwind.config.js`)：** (如果需要手動創建此文件來自訂) 確保設定檔能掃描到所有使用 Tailwind class 的專案檔案，防止生產環境樣式丟失。
    *   [ ] **(可選) 自訂主題 (`tailwind.config.js`)：** (如果需要手動創建此文件來自訂) 初期建議先用預設主題，待核心功能穩定後再統一調整品牌風格。
    *   [x] **配置 Vite 插件：** 在 `vite.config.ts` 中加入 `@tailwindcss/vite` 插件。
    *   [x] **引入 Tailwind 指令至主 CSS：** 在 CSS 進入點 (如 `src/index.css`) 使用 `@import "tailwindcss";`。
    *   [x] **確認 CSS 引入：** 主 CSS 檔案已被應用程式入口載入。
    *   [x] **驗證生效：** 確認 Tailwind 樣式已成功應用。

2.  **[ ] 實現分割畫面基礎 (使用 R3F `<View>`)**
    *   **前置檢查:** 確認已安裝 `@react-three/drei` 函式庫。
    *   [ ] **建立佈局容器 (`div`):** 在負責整體佈局的 React 元件中，使用 Tailwind 的 `flex` 或 `grid` 創建兩個並排或上下排列的 `div` 容器。為每個 `div` 建立並附加一個 `ref`，供後續 `<View>` 元件追蹤。
    *   [ ] **設定 R3F `<Canvas>`:** 在主要的 3D 場景容器元件中設置 `<Canvas>`，並載入共享的 3D 模型、燈光等資源。 **重點：** 只需一個 `<Canvas>`。
    *   [ ] **創建 R3F `<View>` 元件:** 針對上述兩個 `div` 容器，分別創建對應的 `<View>` 元件。將每個 `<View>` 的 `track` 屬性指向相應 `div` 的 `ref`。**架構提示：** `<View>` 元件本身通常放置在 React 元件樹中靠近其追蹤的 `div` 的地方，而不是直接放在 `<Canvas>` 內部深處。
    *   [ ] **配置獨立攝影機:** 為每個 `<View>` 配置其獨立的 React Three Fiber 攝影機 (`PerspectiveCamera`)。調整各自攝影機的位置和視角，使其分別聚焦於模型的頭部和身體區域。**注意：** `makeDefault` 屬性的使用需謹慎，或需手動管理相機啟用狀態。
    *   [ ] **初步驗證:** 確保兩個 `div` 容器都能渲染出 3D 內容，且具有不同的、預期的視角。此階段不要求動畫完美同步。

### Phase 2: 核心元件開發

3.  **[ ] 開發 `FloatingChatWindow.tsx` 元件**
    *   [ ] **創建新元件檔案。**
    *   [ ] **基本結構與樣式:** 使用 Tailwind 設計元件外觀 (背景、邊框、圓角、內外距、字體等)。**注意 `z-index`**，確保浮動視窗總是在 3D 視圖和其他 UI 之上。**建議：** 考慮使用 Headless UI 或 Radix UI 等無樣式元件庫搭配 Tailwind，以更好地處理可訪問性 (如彈窗行為、焦點管理)。
    *   [ ] **整合錄音功能：** 將現有錄音按鈕的邏輯和狀態連接整合進此元件，確保功能完整遷移後可移除舊元件。
    *   [ ] **實現拖動/縮放:**
        *   **安裝依賴：** 引入 `react-draggable` 和 `react-resizable` 函式庫。
        *   **實現拖動：** 包裹元件並設定可拖動的把手區域 (如標題欄)。
        *   **實現縮放：** 包裹元件並設定可縮放的邊界。
        *   **效能提醒:** 避免在拖動/縮放過程中觸發高頻的全局狀態更新，特別是若啟用狀態持久化。考慮在操作結束時 (如 `onStop`) 更新狀態，或使用 debounce/throttle 技術。
        *   **可訪問性考量:** 思考如何讓使用者在非滑鼠環境下也能操作視窗（關閉、觸發等，拖放較難）。
    *   [ ] **狀態管理策略 (本地 vs. 全局):**
        *   **顯示/隱藏狀態：** 由全局 Zustand (`ChatSlice`) 控制。
        *   **位置/大小狀態：**
            *   **方案 A (簡單):** 使用元件內部狀態 (`useState`) 管理，不跨會話保留。
            *   **方案 B (持久化):** 在全局 Zustand (`ChatSlice`) 中管理，並在操作結束時更新。需配置 Zustand 的持久化中間件。
    *   [ ] **連接聊天邏輯：** 對接 Zustand `ChatSlice` 以顯示聊天記錄，並連接到 `ChatService` 或 Action 以發送訊息。

4.  **[ ] 開發 `SettingsPanel.tsx` 元件**
    *   [ ] **創建新元件檔案。**
    *   [ ] **包含控制項：** 加入「開啟調試」、「模型分析工具」、「切換模型」等按鈕。
    *   [ ] **樣式與動畫:** 使用 Tailwind 設計樣式。選擇一種動畫方案 (CSS Transitions 或 Framer Motion) 並應用於面板的顯示/隱藏過渡效果。
    *   [ ] **設計觸發按鈕:** 在主介面合適的角落（如右下角）放置一個觸發此面板顯示/隱藏的圖示按鈕 (⚙️)。**注意：** 確保按鈕位置固定，不易被浮動聊天視窗遮擋。
    *   [ ] **可訪問性:** 確保面板及其內容可透過鍵盤訪問和操作。

### Phase 3: 狀態管理整合與邏輯完善

5.  **[ ] 整合 Zustand 狀態**
    *   [ ] **優化狀態讀取:** 在所有使用 `useStore` 的地方，盡可能使用 **Selector 函數** 精確訂閱所需狀態片段，減少不必要的元件重渲染。
    *   [ ] **實現狀態與 Actions:** 在相應的 Zustand Slices (`AppSlice`, `ChatSlice`) 中添加管理 `SettingsPanel` 和 `FloatingChatWindow` 顯示/隱藏狀態，以及（若選擇持久化）聊天視窗位置/大小的狀態與更新邏輯。
    *   [ ] **連接觸發器與 Actions:** 將設定圖示按鈕、聊天觸發按鈕的點擊事件連接到對應的 Zustand Actions。
    *   [ ] **檢查跨 Slice 影響:** 審視 Actions 是否會間接修改其他 Slice 的狀態，確保數據流清晰可控。
    *   [ ] **配置持久化 (若選擇):** 如果選擇持久化聊天視窗狀態，需設定 Zustand 的 `persist` 中間件。

6.  **[ ] 完善模型動畫邏輯**
    *   [ ] **確認數據流:** 完整追蹤從後端事件到服務層，再到 Zustand Store (`ModelSlice`)，最終反映到 R3F 場景中模型狀態的更新路徑。
    *   [ ] **驗證 `<View>` 更新:** 確保當共享的模型狀態 (如 Morph Targets 或骨骼數據) 更新時，兩個 `<View>` 都能正確渲染出各自視角下的動畫效果（一個更強調面部，一個更強調身體）。

### Phase 4: 樣式細化與逐步重構

7.  **[ ] 細化樣式與動畫**
    *   [ ] **一致性檢查:** 確保動畫時長、緩動曲線等在應用中保持一致。
    *   [ ] **響應式設計:** 使用 Tailwind 的響應式修飾符確保介面在不同螢幕尺寸下表現良好。**建議：** 設計時優先考慮小螢幕佈局。
    *   [ ] **視覺打磨:** 微調顏色、間距、透明度、陰影等視覺元素，達成目標風格。

8.  **[ ] 逐步重構現有元件**
    *   [ ] **制定策略:** 從耦合度低或與新 UI 互動較多的舊元件開始遷移。
    *   [ ] **處理樣式衝突:** 當 Tailwind 與舊 CSS 混合使用時，需注意 CSS 優先級規則。可能需要調整舊 CSS 選擇器或謹慎使用 Tailwind 的 `important` 修飾符。
    *   [ ] **合理使用 `@apply`:** 對於可複用的樣式組合，可在 CSS 中使用 `@apply` 封裝成元件類，以保持 JSX 簡潔，但避免過度使用，以免失去 Tailwind utility-first 的優勢。

### Phase 5: 測試與部署

9.  **[ ] 全面測試**
    *   [ ] **互動場景測試：** 測試單獨及組合使用聊天視窗、設定面板的場景，包括拖動、縮放、重疊等情況。驗證分割視圖在不同長寬比下的表現。
    *   [ ] **邊界條件測試：** 例如將聊天視窗拖動到螢幕邊緣。
    *   [ ] **效能監控：** 使用瀏覽器工具檢查渲染效能，特別關注動畫和 3D 渲染同時進行時的流暢度。
    *   [ ] **跨瀏覽器與響應式測試。**

10. **[ ] 部署**
    *   [ ] **構建確認:** 檢查生產構建過程，確保 Tailwind 的 PurgeCSS 功能正常運作，有效減小最終 CSS 體積。
    *   [ ] **最終線上驗證:** 在部署後的實際環境中，再次快速檢查核心功能和樣式表現。 