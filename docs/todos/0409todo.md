# 2024/04/09 待辦事項

## 1. 語音辨識優化

- [x] 評估並測試替換現有語音辨識模型：已成功切換至 OpenAI Whisper，辨識率顯著提升。
- [ ] 研究模型是否支援自定義詞庫或詞彙微調，以提高特定術語（太空相關）的辨識率 (Whisper 可透過 prompt 提供上下文，待研究)。
- [ ] 檢視音訊輸入品質，考慮加入降噪或回音消除等前處理。
- [ ] 考慮在辨識結果後加入後處理機制（例如關鍵字修正、語意檢查）。

## 2. 回覆時間優化

- [ ] 分析後端 LLM 推理效能與延遲瓶頸。
- [ ] 檢視後端處理流程，評估是否能透過非同步、併行處理或 Pipeline 優化來縮短延遲。
- [ ] 考慮對常用或重複的回覆內容實作快取機制。
- [ ] 檢視前端與後端的資料傳輸，評估是否有網路延遲或渲染阻塞問題。
- [ ] 在前端加入適當的載入提示，改善使用者體感延遲。
- [ ] 建立監控機制，記錄各階段（語音辨識、LLM 推理、網路傳輸）的延遲時間，找出瓶頸。

## 3. TTS 服務更換

- [x] 將 TTS 服務從 Google Cloud TTS 更換為 OpenAI TTS。
- [x] 使用模型 `gpt-4o-mini-tts`。
- [x] 加入 `instructions` 參數引導語音風格：
  ```
  歡迎加入這場為期一年的業餘太空生活探險！每天都會有新的挑戰與事件，可能是來自真實太空環境的威脅，也可能只是些日常小事。你可以隨時觀察並透過語音參與，提供想法或建議。你的每個決定與回應，都將影響這次旅程的發展，以及我的生存狀態與情緒波動。讓我們看看最後能否順利完成這段冒險吧！
  ```
- [x] 確認 `gpt-4o-mini-tts` 模型和 `instructions` 參數的有效性及 API 如何調用。
- [x] 處理音訊時長獲取問題：已改為前端計算 (透過 onloadedmetadata 獲取並存入 Zustand)。

---
### 2024-04-09: 雙模型重構 (身體動畫 + 頭部表情)

**目標:** 將目前的單一模型架構重構為分別處理身體和頭部，身體負責動畫，頭部負責 Morph Targets（表情、口型）。

**階段一：聚焦頭部 - 重命名與遷移**

1.  **[x] 設定檔 (`config/modelConfig.ts`):**
    *   明確區分頭部模型 URL (`HEAD_MODEL_URL = '/models/headonly.glb'`) 和身體模型 URL (`BODY_MODEL_URL = '/models/armature001_model.glb'`)。
    *   移除或標記舊的 `DEFAULT_MODEL_URL` 和 `AVAILABLE_MODELS` (因為模型切換邏輯會改變)。
    *   保留 `EXTERNAL_ANIMATION_PATHS` (暫時與頭部脫鉤，後續給身體用)。
2.  **[x] 狀態管理 (Zustand - `store/slices/`):**
    *   將 `modelSlice.ts` 重命名為 `headSlice.ts`。
    *   在 `headSlice.ts` 內部：
        *   將狀態 `modelUrl` 重命名為 `headModelUrl`，並使用 `HEAD_MODEL_URL` 作為初始值。
        *   移除動畫相關狀態：`availableAnimations`, `currentAnimation`。
        *   保留 Morph Targets 相關狀態：`morphTargets`, `morphTargetDictionary`。
        *   將 `modelLoaded` 重命名為 `headModelLoaded`。
        *   更新對應的 Actions (`setModelUrl` -> `setHeadModelUrl`, etc.)。
    *   更新 `store/index.ts` 中的導入和組合 slice 的邏輯。
3.  **[x] 服務層 (`services/`):**
    *   將 `ModelService.ts` 重命名為 `HeadService.ts`。
    *   在 `HeadService.ts` 內部：
        *   更新服務邏輯，使其專注於加載頭部模型 (`HEAD_MODEL_URL`) 和處理 Morph Targets。
        *   移除 `setAvailableAnimations`, `setCurrentAnimation`, `selectAnimation` 等動畫相關方法。
        *   更新 `useModelService` Hook 為 `useHeadService`，並調整其返回值，移除動畫相關內容。
    *   更新所有導入 `ModelService` 或 `useModelService` 的地方。
4.  **[x] 組件 (`components/`):**
    *   將 `Model.tsx` 重命名為 `HeadModel.tsx`。
    *   在 `HeadModel.tsx` 內部：
        *   更新 props 和內部邏輯，使其接收 `headModelUrl`。
        *   移除加載外部動畫 (`EXTERNAL_ANIMATION_PATHS`) 的邏輯。
        *   移除 `useAnimations` Hook 和所有與動畫播放相關的 `useEffect` 及 `useFrame` 邏輯。
        *   保留加載模型、提取 Morph Target 字典、更新 Morph Target influence 的邏輯。
        *   更新 `setModelLoaded` 為 `setHeadModelLoaded`。
    *   更新 `SceneContainer.tsx` 中導入和渲染 `HeadModel.tsx`。
5.  **[x] 應用主層 (`App.tsx`):**
    *   更新導入，使用 `useHeadService`。
    *   調整傳遞給 `SceneContainer` -> `HeadModel` 的 props (傳遞 `headModelUrl` 等)。
    *   調整傳遞給 `SettingsPanel` 的 props：
        *   暫時移除 `availableAnimations`, `currentAnimation`, `selectAnimation`。
        *   保留 Morph Targets 控制相關 props。
        *   更新 `isModelLoaded` 為 `isHeadModelLoaded`。
        *   暫時禁用或移除「切換模型」按鈕 (`handleModelSwitch`)，因為邏輯需要重新設計。
6.  **[x] UI 面板 (`SettingsPanel.tsx`):**
    *   根據 `App.tsx` 傳遞的 props 變化，移除或禁用動畫控制按鈕。
    *   確保 Morph Targets 控制仍然可用。
    *   更新依賴 `isModelLoaded` 的地方為 `isHeadModelLoaded`。
    *   移除或禁用「切換模型」按鈕。

**-- 階段一完成 --**

**階段二：添加身體模型**

7.  **[x] 狀態管理 (Zustand):**
    *   創建 `bodySlice.ts`，包含 `bodyModelUrl`, `bodyModelLoaded`, `availableAnimations`, `currentAnimation` 狀態及 actions。
    *   更新 `store/index.ts` 加入 `bodySlice`。
8.  **[x] 服務層:**
    *   創建 `BodyService.ts` 和 `useBodyService` Hook。
9.  **[x] 組件:**
    *   創建 `BodyModel.tsx` 組件，負責：
        *   加載身體模型 (`BODY_MODEL_URL`)。
        *   加載外部動畫 (`EXTERNAL_ANIMATION_PATHS`)。
        *   使用 `useAnimations`。
        *   根據 `currentAnimation` 狀態播放動畫。
    *   修改 `SceneContainer.tsx`，同時渲染 `<HeadModel>` (放大/定位) 和 `<BodyModel>` (放大)。
10. **[x] 應用主層 (`App.tsx`):**
    *   同時使用 `useHeadService` 和 `useBodyService`。
    *   管理身體相關狀態並傳遞 props 給 `BodyModel` (via `SceneContainer`)。
    *   將動畫相關 props (`availableAnimations`, `currentAnimation`, `selectAnimation`) 傳遞給 `SettingsPanel`。
11. **[x] UI 面板 (`SettingsPanel.tsx`):**
    *   重新啟用動畫控制 UI，連接到 `bodySlice` 和 `useBodyService`。
    *   調整佈局以區分頭部和身體控制。

**-- 階段二完成 --**

**階段三：整合基礎後端動畫同步**

12. [x] **前端 - 動畫名稱處理:**
    *   創建工具函數: (`src/utils/animationUtils.ts`) 創建 `getFriendlyAnimationName(path)`。
    *   生成友好名稱列表: 在 `BodyModel.tsx` 使用工具函數處理 `EXTERNAL_ANIMATION_PATHS`，生成 `friendlyAnimationNames: string[]`。
    *   (可選) 發送列表至後端: (暫緩)
13. [x] **前端 - 動畫加載與映射:**
    *   順序加載: 確保 `useExternalAnimations` 或相關邏輯按穩定順序加載動畫。
    *   獲取內部名稱: 在 `BodyModel.tsx` 從 `useAnimations` 獲取 `internalAnimationNames: string[]`。
    *   創建映射: 創建從友好名稱到 `AnimationAction` 的精確映射 `friendlyToActionMap` (使用 `mixer.clipAction`)。
14. [x] **前端 - 狀態管理:**
    *   `bodySlice`: `availableAnimations` 和 `currentAnimation` 狀態存儲**友好名稱**。`selectAnimation` action 接收**友好名稱**。
    *   `BodyModel.tsx`: 調用 `setAvailableAnimations(friendlyAnimationNames)`。
15. [x] **前端 - 組件 (`BodyModel.tsx`):**
    *   動畫播放 `useEffect`: 讀取 `currentAnimation` (友好名稱)，使用 `friendlyToActionMap` 查找並播放精確的 `AnimationAction`。
    *   (可選) 預設動畫: (待處理，如果需要)
16. [x] **前端 - UI (`SettingsPanel.tsx`):**
    *   確認 UI 顯示和交互基於**友好名稱**。
17. [ ] **前端 - Idle 動畫準備:**
    *   確保 `EXTERNAL_ANIMATION_PATHS` 中包含 Idle 動畫並正確映射。
18. [ ] **前端 - Audio & Body 同步邏輯:**
    *   監聽語音狀態 (`isSpeaking`)。
    *   語音開始時，讀取 `suggestedAnimationName` 並調用 `selectAnimation`。
    *   語音結束時，調用 `selectAnimation('Idle')`。
19. [ ] **前端 - WebSocket 訊息處理:**
    *   修改訊息格式以包含 `bodyAnimationName` (友好名稱)。
    *   更新解析邏輯，將 `bodyAnimationName` 存儲到 Zustand 狀態。
20. [ ] **後端 - (概念性):**
    *   發送訊息時附帶 `bodyAnimationName`。
21. [ ] **測試與調試:**
    *   測試基礎同步流程。

**階段四：添加身體 Morph Target 控制 (可選)**

22. [ ] **調查:** 檢查身體模型是否包含 Morph Targets。
23. [ ] **實現 (如果包含):**
    *   在 `BodyModel.tsx` 提取 Morph Targets。
    *   在 Zustand 中添加狀態和 actions。
    *   (可選) 更新 WebSocket 處理。
24. [ ] **測試:** 測試 Morph Target 控制。

**階段五：高級動畫控制 (序列、分層、混合)**

25. [ ] **研究與設計:** 探索 Animation Sequencing, Layering (Masking), Blending 的實現方案 (e.g., Three.js `AnimationMixer`, `PropertyBinding`, 骨骼操作)。
26. [ ] **實現動畫序列:** 
    *   設計後端指令格式以傳遞動畫序列及各段時長。
    *   修改前端狀態管理和播放邏輯以處理序列。
27. [ ] **實現動畫分層 (進階):**
    *   研究或實現骨骼遮罩 (Masking) 機制。
    *   設計後端指令以指定基礎層和疊加層動畫。
    *   修改播放邏輯以應用遮罩和疊加。
28. [ ] **實現動態混合 (進階):** 
    *   設計後端指令或前端邏輯以根據參數（如情緒強度）調整動畫權重 (`weight`)。
    *   修改播放邏輯以動態設置 `weight`。
29. [ ] **測試:** 分別測試序列、分層、混合功能。