# 2024/04/09 待辦事項

## 1. 語音辨識優化

- [x] 評估並測試替換現有語音辨識模型：已成功切換至 OpenAI Whisper，辨識率顯著提升。
- [ ] 研究模型是否支援自定義詞庫或詞彙微調，以提高特定術語（太空相關）的辨識率 (Whisper 可透過 prompt 提供上下文，待研究)。
- [ ] 檢視音訊輸入品質，考慮加入降噪或回音消除等前處理。
- [ ] 考慮在辨識結果後加入後處理機制（例如關鍵字修正、語意檢查）。

## 2. 回覆時間優化

- [ ] 分析後端 LLM 推理效能與延遲瓶頸。
- [ ] 檢視後端處理流程，評估是否能透過非同步、併行處理或 Pipeline 優化來縮短延遲。
- [ ] 考慮對常用或重複的回覆內容實作快取機制。
- [ ] 檢視前端與後端的資料傳輸，評估是否有網路延遲或渲染阻塞問題。
- [ ] 在前端加入適當的載入提示，改善使用者體感延遲。
- [ ] 建立監控機制，記錄各階段（語音辨識、LLM 推理、網路傳輸）的延遲時間，找出瓶頸。

## 3. TTS 服務更換

- [x] 將 TTS 服務從 Google Cloud TTS 更換為 OpenAI TTS。
- [x] 使用模型 `gpt-4o-mini-tts`。
- [x] 加入 `instructions` 參數引導語音風格：
  ```
  歡迎加入這場為期一年的業餘太空生活探險！每天都會有新的挑戰與事件，可能是來自真實太空環境的威脅，也可能只是些日常小事。你可以隨時觀察並透過語音參與，提供想法或建議。你的每個決定與回應，都將影響這次旅程的發展，以及我的生存狀態與情緒波動。讓我們看看最後能否順利完成這段冒險吧！
  ```
- [x] 確認 `gpt-4o-mini-tts` 模型和 `instructions` 參數的有效性及 API 如何調用。
- [x] 處理音訊時長獲取問題：已改為前端計算 (透過 onloadedmetadata 獲取並存入 Zustand)。

---
### 2024-04-09: 雙模型重構 (身體動畫 + 頭部表情)

**目標:** 將目前的單一模型架構重構為分別處理身體和頭部，身體負責動畫，頭部負責 Morph Targets（表情、口型）。

**階段一：聚焦頭部 - 重命名與遷移**

1.  **[x] 設定檔 (`config/modelConfig.ts`):**
    *   明確區分頭部模型 URL (`HEAD_MODEL_URL = '/models/headonly.glb'`) 和身體模型 URL (`BODY_MODEL_URL = '/models/armature001_model.glb'`)。
    *   移除或標記舊的 `DEFAULT_MODEL_URL` 和 `AVAILABLE_MODELS` (因為模型切換邏輯會改變)。
    *   保留 `EXTERNAL_ANIMATION_PATHS` (暫時與頭部脫鉤，後續給身體用)。
2.  **[x] 狀態管理 (Zustand - `store/slices/`):**
    *   將 `modelSlice.ts` 重命名為 `headSlice.ts`。
    *   在 `headSlice.ts` 內部：
        *   將狀態 `modelUrl` 重命名為 `headModelUrl`，並使用 `HEAD_MODEL_URL` 作為初始值。
        *   移除動畫相關狀態：`availableAnimations`, `currentAnimation`。
        *   保留 Morph Targets 相關狀態：`morphTargets`, `morphTargetDictionary`。
        *   將 `modelLoaded` 重命名為 `headModelLoaded`。
        *   更新對應的 Actions (`setModelUrl` -> `setHeadModelUrl`, etc.)。
    *   更新 `store/index.ts` 中的導入和組合 slice 的邏輯。
3.  **[x] 服務層 (`services/`):**
    *   將 `ModelService.ts` 重命名為 `HeadService.ts`。
    *   在 `HeadService.ts` 內部：
        *   更新服務邏輯，使其專注於加載頭部模型 (`HEAD_MODEL_URL`) 和處理 Morph Targets。
        *   移除 `setAvailableAnimations`, `setCurrentAnimation`, `selectAnimation` 等動畫相關方法。
        *   更新 `useModelService` Hook 為 `useHeadService`，並調整其返回值，移除動畫相關內容。
    *   更新所有導入 `ModelService` 或 `useModelService` 的地方。
4.  **[x] 組件 (`components/`):**
    *   將 `Model.tsx` 重命名為 `HeadModel.tsx`。
    *   在 `HeadModel.tsx` 內部：
        *   更新 props 和內部邏輯，使其接收 `headModelUrl`。
        *   移除加載外部動畫 (`EXTERNAL_ANIMATION_PATHS`) 的邏輯。
        *   移除 `useAnimations` Hook 和所有與動畫播放相關的 `useEffect` 及 `useFrame` 邏輯。
        *   保留加載模型、提取 Morph Target 字典、更新 Morph Target influence 的邏輯。
        *   更新 `setModelLoaded` 為 `setHeadModelLoaded`。
    *   更新 `SceneContainer.tsx` 中導入和渲染 `HeadModel.tsx`。
5.  **[x] 應用主層 (`App.tsx`):**
    *   更新導入，使用 `useHeadService`。
    *   調整傳遞給 `SceneContainer` -> `HeadModel` 的 props (傳遞 `headModelUrl` 等)。
    *   調整傳遞給 `SettingsPanel` 的 props：
        *   暫時移除 `availableAnimations`, `currentAnimation`, `selectAnimation`。
        *   保留 Morph Targets 控制相關 props。
        *   更新 `isModelLoaded` 為 `isHeadModelLoaded`。
        *   暫時禁用或移除「切換模型」按鈕 (`handleModelSwitch`)，因為邏輯需要重新設計。
6.  **[x] UI 面板 (`SettingsPanel.tsx`):**
    *   根據 `App.tsx` 傳遞的 props 變化，移除或禁用動畫控制按鈕。
    *   確保 Morph Targets 控制仍然可用。
    *   更新依賴 `isModelLoaded` 的地方為 `isHeadModelLoaded`。
    *   移除或禁用「切換模型」按鈕。

**-- 階段一完成 --**

**階段二：添加身體模型**

7.  **[x] 狀態管理 (Zustand):**
    *   創建 `bodySlice.ts`，包含 `bodyModelUrl`, `bodyModelLoaded`, `availableAnimations`, `currentAnimation` 狀態及 actions。
    *   更新 `store/index.ts` 加入 `bodySlice`。
8.  **[x] 服務層:**
    *   創建 `BodyService.ts` 和 `useBodyService` Hook。
9.  **[x] 組件:**
    *   創建 `BodyModel.tsx` 組件，負責：
        *   加載身體模型 (`BODY_MODEL_URL`)。
        *   加載外部動畫 (`EXTERNAL_ANIMATION_PATHS`)。
        *   使用 `useAnimations`。
        *   根據 `currentAnimation` 狀態播放動畫。
    *   修改 `SceneContainer.tsx`，同時渲染 `<HeadModel>` (放大/定位) 和 `<BodyModel>` (放大)。
10. **[x] 應用主層 (`App.tsx`):**
    *   同時使用 `useHeadService` 和 `useBodyService`。
    *   管理身體相關狀態並傳遞 props 給 `BodyModel` (via `SceneContainer`)。
    *   將動畫相關 props (`availableAnimations`, `currentAnimation`, `selectAnimation`) 傳遞給 `SettingsPanel`。
11. **[x] UI 面板 (`SettingsPanel.tsx`):**
    *   重新啟用動畫控制 UI，連接到 `bodySlice` 和 `useBodyService`。
    *   調整佈局以區分頭部和身體控制。

**-- 階段二完成 --**

**階段三：整合後端驅動的身體動畫**

12. **前端 - 動畫列表準備:**
    *   **獲取動畫名稱:** 在 `modelConfig.ts` 或創建工具函數，從 `EXTERNAL_ANIMATION_PATHS` 提取動畫名稱列表 (`string[]`)。
    *   **(可選) 發送列表至後端:** 修改 `WebSocketService`，連接成功後將動畫列表發送給後端 (定義 `clientAnnounceAnimations` 訊息類型)。
13. **前端 - WebSocket 訊息處理:**
    *   **定義新訊息格式:** 與後端協商接收身體動畫指令的 JSON 格式 (e.g., `type: "playBodyAnimation"`, `payload: { name, duration?, loop? }`)。
    *   **更新訊息解析邏輯:** 修改 `useWebSocket` Hook 處理新訊息類型。
14. **前端 - 狀態管理 (`bodySlice.ts`):**
    *   **添加新 Action:** 創建 `triggerBodyAnimation(payload)` action。
    *   **更新狀態:** action 應設置 `currentAnimation`。
    *   **(進階/可選):** 考慮添加計時器處理非循環動畫的自動停止。
15. **前端 - 組件 (`BodyModel.tsx`):**
    *   **檢查動畫播放:** 確認 `useEffect` 邏輯滿足需求，（可選）添加非循環動畫處理。
    *   **(可選) 預設動畫:** 考慮添加 Idle 動畫。
16. **後端 - (概念性):**
    *   實現接收前端動畫列表的邏輯。
    *   實現文本到動畫/表情的映射邏輯。
    *   實現按照新格式發送 WebSocket 訊息。
17. **測試與調試:**
    *   發送模擬的 `playBodyAnimation` 訊息測試。
    *   測試動畫切換、非循環動畫表現。
    *   測試頭身同步效果。